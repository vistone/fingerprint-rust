//! DNS domain resolution example
//!
//! Usage:
//! cargo run --example resolve_domains --features dns,rustls-tls #[cfg(feature = "dns")]
use fingerprint::dns::{ load_domain_ips, save_domain_ips, DNSResolver, DomainIPs, IPInfoClient, ServerCollector,
};
#[cfg(feature = "dns")]
use std::collections::HashSet;
#[cfg(feature = "dns")]
use std::path::PathBuf;
#[cfg(feature = "dns")]
use std::sync::Arc;
#[cfg(feature = "dns")]
use std::time::Duration; #[cfg(feature = "dns")]
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> { println!("ğŸ” DNS domain resolution example"); println!("==================\n"); // IPInfo token let token = "f6babc99a5ec26"; let ipinfo_client = IPInfoClient::new(token.to_string(), Duration::from_secs(20)); // List of domains to resolve let domains = vec!["kh.google.com", "khmdb.google.com"]; // Collect global DNS servers println!("ğŸ“¡ æ­£Collect global DNS servers..."); let server_pool = ServerCollector::collect_all(Some(Duration::from_secs(30))).await; println!("âœ… Collected {} DNS servers", server_pool.len()); // Create resolver with collected DNS servers let resolver = DNSResolver::with_server_pool(Duration::from_secs(4), Arc::new(server_pool)); // Create output directory let output_dir = PathBuf::from("./dns_output"); std::fs::create_dir_all(&output_dir)?; println!("ğŸ“¡ Start resolving domains...\n"); // Resolve each domain for domain in &domains { println!("Resolving domain: {}", domain); // DNS resolution let dns_result = resolver.resolve(domain).await?; println!( " âœ… DNS resolutionæˆ: {} IPv4 addresses, {} IPv6 addresses", dns_result.ips.ipv4.len(), dns_result.ips.ipv6.len() ); // Load existing IP informationï¼ˆfor deduplication to avoid duplicate IPInfo queriesï¼‰ println!(" ğŸ“‚ Load locally stored IP information..."); let existing = load_domain_ips(domain, &output_dir)?; // Extract all resolved IPsï¼ˆDNS resolutionæœå·²å»é‡ï¼‰ let all_ipv4: HashSet<String> = dns_result .ips .ipv4 .iter() .map(|ip_info| ip_info.ip.clone()) .collect(); let all_ipv6: HashSet<String> = dns_result .ips .ipv6 .iter() .map(|ip_info| ip_info.ip.clone()) .collect(); // Extract existing IPs from local storage let existing_ipv4: HashSet<String> = existing .as_ref() .map(|e| e.ipv4.iter().map(|ip| ip.ip.clone()).collect()) .unwrap_or_default(); let existing_ipv6: HashSet<String> = existing .as_ref() .map(|e| e.ipv6.iter().map(|ip| ip.ip.clone()).collect()) .unwrap_or_default(); // Find newly discovered IPsï¼ˆAfter deduplication with local storage, only query these new IPsï¼‰ let new_ipv4: Vec<String> = all_ipv4.difference(&existing_ipv4).cloned().collect(); let new_ipv6: Vec<String> = all_ipv6.difference(&existing_ipv6).cloned().collect(); println!(" ğŸ“Š IP statisticsï¼ˆdeduplicated with local storageï¼‰:"); println!( " IPv4: Total {} ï¼Œlocally exists {} ï¼Œnewly discovered {} ï¼ˆwill query these {} ï¼‰", all_ipv4.len(), existing_ipv4.len(), new_ipv4.len(), new_ipv4.len() ); println!( " IPv6: Total {} ï¼Œlocally exists {} ï¼Œnewly discovered {} ï¼ˆwill query these {} ï¼‰", all_ipv6.len(), existing_ipv6.len(), new_ipv6.len(), new_ipv6.len() ); // Build final domain_ips, copy existing data first let mut domain_ips = DomainIPs::new(); // Copy existing IPv4 information if let Some(existing) = &existing { for existing_ip in &existing.ipv4 { if all_ipv4.contains(&existing_ip.ip) { domain_ips.ipv4.push(existing_ip.clone()); } } } // Copy existing IPv6 information if let Some(existing) = &existing { for existing_ip in &existing.ipv6 { if all_ipv6.contains(&existing_ip.ip) { domain_ips.ipv6.push(existing_ip.clone()); } } } // åªæŸ¥newly discovered IPv4 çš„è¯¦ç»†ä¿¡æ¯ï¼ˆdeduplicated with local storageï¼‰ if !new_ipv4.is_empty() { println!( " ğŸ“¡ Getnewly discovered IPv4 è¯¦ç»†ä¿¡æ¯ï¼ˆ{} IPï¼Œdeduplicated, concurrent processingï¼‰...", new_ipv4.len() ); let ipv4_results = ipinfo_client.get_ip_infos(new_ipv4.clone(), 50).await; eprintln!(" [IPInfo] IPv4 Query completed: {} results", ipv4_results.len()); for (ip, ip_result) in ipv4_results { match ip_result { Ok(mut ip_info) => { // Keep original IPï¼ˆbecause IPInfo may return different formatï¼‰ ip_info.ip = ip.clone(); domain_ips.ipv4.push(ip_info); } Err(e) => { eprintln!(" [IPInfo] âš ï¸ Get {} detailed info failed: {}", ip, e); // Even if failed, save basic IP info domain_ips.ipv4.push(fingerprint::dns::IPInfo::new(ip)); } } } eprintln!( " [IPInfo] IPv4 è¯¦ç»†ä¿¡Getæˆ: {} ", domain_ips.ipv4.len() ); } else { println!(" âœ… IPv4 hasnewly discovered IPï¼Œè·³è¿‡ IPInfo æŸ¥è¯¢"); } // åªæŸ¥newly discovered IPv6 çš„è¯¦ç»†ä¿¡æ¯ï¼ˆdeduplicated with local storageï¼‰ if !new_ipv6.is_empty() { println!( " ğŸ“¡ Getnewly discovered IPv6 è¯¦ç»†ä¿¡æ¯ï¼ˆ{} IPï¼Œdeduplicated, concurrent processingï¼‰...", new_ipv6.len() ); let ipv6_results = ipinfo_client.get_ip_infos(new_ipv6.clone(), 50).await; eprintln!(" [IPInfo] IPv6 Query completed: {} results", ipv6_results.len()); for (ip, ip_result) in ipv6_results { match ip_result { Ok(mut ip_info) => { ip_info.ip = ip.clone(); domain_ips.ipv6.push(ip_info); } Err(e) => { eprintln!(" [IPInfo] âš ï¸ Get {} detailed info failed: {}", ip, e); domain_ips.ipv6.push(fingerprint::dns::IPInfo::new(ip)); } } } eprintln!( " [IPInfo] IPv6 è¯¦ç»†ä¿¡Getæˆ: {} ", domain_ips.ipv6.len() ); } else { println!(" âœ… IPv6 hasnewly discovered IPï¼Œè·³è¿‡ IPInfo æŸ¥è¯¢"); } println!( " âœ… IP ä¿¡Getæˆ: {} IPv4 addresses, {} IPv6 addresses\n", domain_ips.ipv4.len(), domain_ips.ipv6.len() ); // Save in three formatsï¼ˆsave_domain_ips will save JSON, YAML, TOML simultaneouslyï¼‰ save_domain_ips(domain, &domain_ips, &output_dir)?; println!(" âœ… JSON saved: {}/{}.json", output_dir.display(), domain); println!(" âœ… YAML saved: {}/{}.yaml", output_dir.display(), domain); println!(" âœ… TOML saved: {}/{}.toml", output_dir.display(), domain); println!(); } println!("ğŸ‰ All domain resolution completedï¼"); println!("ğŸ“ Output directory: {}", output_dir.display()); // æ˜¾ç¤º JSON ç¤ºä¾‹å†…å®¹ println!("\nğŸ“„ JSON Format example:"); let json_path = output_dir.join("kh.google.com.json"); if json_path.exists() { let content = std::fs::read_to_string(&json_path)?; println!("{}", content); } Ok(())
} #[cfg(not(feature = "dns"))]
fn main() { println!("This example requires enabling 'dns' feature"); println!("ä½¿ç”¨æ–¹æ³•: cargo run --example resolve_domains --features dns,rustls-tls");
}
