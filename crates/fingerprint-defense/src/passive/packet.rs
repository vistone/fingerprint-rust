//! countpacketParsemodule
//!
//! providebottomlayercountpacketParseFeatures. use bytes::Bytes;
use std::net::IpAddr; /// countpacket
#[derive(Debug, Clone)]
pub struct Packet { /// timestamp pub timestamp: u64, /// source IP pub src_ip: IpAddr, /// target IP pub dst_ip: IpAddr, /// sourceport pub src_port: u16, /// targetport pub dst_port: u16, /// IP protocolversion pub ip_version: u8, /// TTL pub ttl: u8, /// IP flag pub ip_flags: u8, /// countpacketload pub payload: Bytes, /// TCP headerinfo ( if exists) pub tcp_header: Option<TcpHeader>,
} /// TCP headerinfo
#[derive(Debug, Clone)]
pub struct TcpHeader { /// sequencenumber pub seq: u32, /// confirmnumber pub ack: Option<u32>, /// windowsize pub window: u16, /// TCP flag pub flags: u8, /// TCP options pub options: Vec<TcpOption>,
} /// TCP options
#[derive(Debug, Clone)]
pub struct TcpOption { pub kind: u8, pub data: Vec<u8>,
} /// countpacketParseer
pub struct PacketParser; impl PacketParser { /// from originalbeginningcountpacketParse pub fn parse(raw_packet: &[u8]) -> Result<Packet, PacketError> { // Parse IP header if raw_packet.len() < 20 { return Err(PacketError::TooShort); } let version = (raw_packet[0] >> 4) & 0x0F; match version { 4 => Self::parse_ipv4(raw_packet), 6 => Self::parse_ipv6(raw_packet), _ => Err(PacketError::InvalidVersion), } } /// Parse IPv4 countpacket fn parse_ipv4(raw_packet: &[u8]) -> Result<Packet, PacketError> { if raw_packet.len() < 20 { return Err(PacketError::TooShort); } let ihl = (raw_packet[0] & 0x0F) as usize; // securityCheck：IHL mustat least as 5 (20 bytes), at most as 15 (60 bytes) if !(5..=15).contains(&ihl) { return Err(PacketError::Other("invalid IHL value".to_string())); } let header_len = ihl * 4; // securityCheck：ensurecountpacketenoughlong if raw_packet.len() < header_len { return Err(PacketError::TooShort); } let _total_length = u16::from_be_bytes([raw_packet[2], raw_packet[3]]) as usize; let ttl = raw_packet[8]; let protocol = raw_packet[9]; let ip_flags = (raw_packet[6] >> 5) & 0x07; let src_ip = IpAddr::from([ raw_packet[12], raw_packet[13], raw_packet[14], raw_packet[15], ]); let dst_ip = IpAddr::from([ raw_packet[16], raw_packet[17], raw_packet[18], raw_packet[19], ]); let payload = Bytes::copy_from_slice(&raw_packet[header_len..]); // Based onprotocoltypeParse let (src_port, dst_port, tcp_header) = match protocol { 6 => { // TCP Self::parse_tcp(&payload)? } 17 => { // UDP Self::parse_udp(&payload)? } 1 => { // ICMP Self::parse_icmp(&payload)? } _ => { // otherprotocol (0, 0, None) } }; Ok(Packet { timestamp: 0, // TODO: from pcap Get src_ip, dst_ip, src_port, dst_port, ip_version: 4, ttl, ip_flags, payload, tcp_header, }) } /// Parse IPv6 countpacket fn parse_ipv6(raw_packet: &[u8]) -> Result<Packet, PacketError> { if raw_packet.len() < 40 { return Err(PacketError::TooShort); } // IPv6 headerfixed 40 bytes // version(4) + trafficclassdistinguish(8) + streamtag(20) = front 4 bytes let version = (raw_packet[0] >> 4) & 0x0F; if version != 6 { return Err(PacketError::InvalidVersion); } // loadlength (16, bytes 4-5) let payload_length = u16::from_be_bytes([raw_packet[4], raw_packet[5]]) as usize; // nextheader (protocoltype, bytes 6) let next_header = raw_packet[6]; // jumpcountlimit (TTL, bytes 7) let hop_limit = raw_packet[7]; // sourceaddress (128, bytes 8-23) let src_ip = IpAddr::from([ raw_packet[8], raw_packet[9], raw_packet[10], raw_packet[11], raw_packet[12], raw_packet[13], raw_packet[14], raw_packet[15], raw_packet[16], raw_packet[17], raw_packet[18], raw_packet[19], raw_packet[20], raw_packet[21], raw_packet[22], raw_packet[23], ]); // targetaddress (128, bytes 24-39) let dst_ip = IpAddr::from([ raw_packet[24], raw_packet[25], raw_packet[26], raw_packet[27], raw_packet[28], raw_packet[29], raw_packet[30], raw_packet[31], raw_packet[32], raw_packet[33], raw_packet[34], raw_packet[35], raw_packet[36], raw_packet[37], raw_packet[38], raw_packet[39], ]); // loadcountdata ( from bytes 40 start) let payload_start = 40; let payload_end = (payload_start + payload_length).min(raw_packet.len()); let payload = Bytes::copy_from_slice(&raw_packet[payload_start..payload_end]); // Based onnextheaderprotocolParse let (src_port, dst_port, tcp_header) = match next_header { 6 => { // TCP over IPv6 Self::parse_tcp(&payload)? } 17 => { // UDP over IPv6 Self::parse_udp(&payload)? } 58 => { // ICMPv6 Self::parse_icmp(&payload)? } _ => { // otherprotocol (0, 0, None) } }; Ok(Packet { timestamp: 0, src_ip, dst_ip, src_port, dst_port, ip_version: 6, ttl: hop_limit, ip_flags: 0, payload, tcp_header, }) } /// Parse UDP header fn parse_udp(data: &[u8]) -> Result<(u16, u16, Option<TcpHeader>), PacketError> { if data.len() < 8 { return Err(PacketError::TooShort); } let src_port = u16::from_be_bytes([data[0], data[1]]); let dst_port = u16::from_be_bytes([data[2], data[3]]); let _length = u16::from_be_bytes([data[4], data[5]]); let _checksum = u16::from_be_bytes([data[6], data[7]]); // UDP no TCP headerstruct, return None Ok((src_port, dst_port, None)) } /// Parse ICMP header fn parse_icmp(_data: &[u8]) -> Result<(u16, u16, Option<TcpHeader>), PacketError> { // ICMP noportgeneral, return 0 // ICMP type and code in data[0] and data[1] Ok((0, 0, None)) } /// Parse TCP header fn parse_tcp(data: &[u8]) -> Result<(u16, u16, Option<TcpHeader>), PacketError> { if data.len() < 20 { return Err(PacketError::TooShort); } let src_port = u16::from_be_bytes([data[0], data[1]]); let dst_port = u16::from_be_bytes([data[2], data[3]]); let seq = u32::from_be_bytes([data[4], data[5], data[6], data[7]]); let ack = if data[13] & 0x10 != 0 { Some(u32::from_be_bytes([data[8], data[9], data[10], data[11]])) } else { None }; let data_offset = ((data[12] >> 4) & 0x0F) as usize; // securityCheck：data_offset mustat least as 5 (20 bytes), at most as 15 (60 bytes) if !(5..=15).contains(&data_offset) { return Err(PacketError::Other("invalid TCP data offset".to_string())); } let flags = data[13]; let window = u16::from_be_bytes([data[14], data[15]]); // Parse TCP options let mut options = Vec::new(); let header_len = data_offset * 4; // securityCheck：ensurenotwillexceedboundaryaccess if header_len > data.len() { return Err(PacketError::TooShort); } if header_len > 20 { let mut offset = 20; while offset < header_len { if offset >= data.len() { break; } let kind = data[offset]; if kind == 0 { // End of options break; } else if kind == 1 { // NOP offset += 1; continue; } else { if offset + 1 >= data.len() { break; } let length = data[offset + 1] as usize; // securityCheck：length mustat least as 2, and cannotcauseexceedboundary if length < 2 || offset + length > data.len() || offset + length > header_len { break; } let option_data = data[offset + 2..offset + length].to_vec(); options.push(TcpOption { kind, data: option_data, }); offset += length; } } } let tcp_header = TcpHeader { seq, ack, window, flags, options, }; Ok((src_port, dst_port, Some(tcp_header))) }
} /// countpacketParseerror
#[derive(Debug, thiserror::Error)]
pub enum PacketError { #[error("countpackettoo short")] TooShort, #[error("invalid IP version")] InvalidVersion, #[error("notimplement: {0}")] NotImplemented(&'static str), #[error("othererror: {0}")] Other(String),
} impl From<PacketError> for String { fn from(err: PacketError) -> Self { err.to_string() }
} #[cfg(test)]
mod security_tests { use super::*; #[test] fn test_invalid_ihl_zero() { // IHL = 0 (invalid, must be at least 5) let mut packet = vec![0x00; 20]; packet[0] = 0x40; // Version 4, IHL 0 packet[12..16].copy_from_slice(&[192, 168, 1, 1]); // src IP packet[16..20].copy_from_slice(&[192, 168, 1, 2]); // dst IP let result = PacketParser::parse(&packet); assert!(result.is_err(), "shouldrefuse IHL = 0 countpacket"); } #[test] fn test_invalid_ihl_small() { // IHL = 4 (invalid, must be at least 5) let mut packet = vec![0x00; 20]; packet[0] = 0x44; // Version 4, IHL 4 packet[12..16].copy_from_slice(&[192, 168, 1, 1]); // src IP packet[16..20].copy_from_slice(&[192, 168, 1, 2]); // dst IP let result = PacketParser::parse(&packet); assert!(result.is_err(), "shouldrefuse IHL < 5 countpacket"); } #[test] fn test_ihl_causing_overflow() { // Test case where IHL * 4 would access beyond packet boundary let mut packet = vec![0x00; 20]; packet[0] = 0x4F; // Version 4, IHL 15 (would need 60 bytes) packet[12..16].copy_from_slice(&[192, 168, 1, 1]); // src IP packet[16..20].copy_from_slice(&[192, 168, 1, 2]); // dst IP let result = PacketParser::parse(&packet); assert!( result.is_err(), "shouldrefuse header_len exceed packet lengthcountpacket" ); } #[test] fn test_valid_minimal_ipv4_packet() { // Test that a valid minimal packet still works let mut packet = vec![0x00; 20]; packet[0] = 0x45; // Version 4, IHL 5 packet[2] = 0x00; // Total length high byte packet[3] = 0x14; // Total length low byte (20 bytes) packet[12..16].copy_from_slice(&[192, 168, 1, 1]); // src IP packet[16..20].copy_from_slice(&[192, 168, 1, 2]); // dst IP let result = PacketParser::parse(&packet); assert!( result.is_ok(), "validminimum IPv4 countpacketshouldParsesuccess" ); } #[test] fn test_invalid_tcp_data_offset_zero() { // Create a valid IPv4 packet with TCP let mut packet = vec![0x00; 40]; packet[0] = 0x45; // Version 4, IHL 5 packet[2] = 0x00; // Total length high byte packet[3] = 0x28; // Total length low byte (40 bytes) packet[9] = 6; // Protocol: TCP packet[12..16].copy_from_slice(&[192, 168, 1, 1]); // src IP packet[16..20].copy_from_slice(&[192, 168, 1, 2]); // dst IP // TCP header - set data offset to 0 (invalid) packet[20..22].copy_from_slice(&[0x00, 0x50]); // src port 80 packet[22..24].copy_from_slice(&[0x00, 0x50]); // dst port 80 packet[32] = 0x00; // Data offset = 0 (invalid) let result = PacketParser::parse(&packet); assert!( result.is_err(), "shouldrefuse data_offset = 0 TCP countpacket" ); } #[test] fn test_invalid_tcp_data_offset_small() { // Create a valid IPv4 packet with TCP let mut packet = vec![0x00; 40]; packet[0] = 0x45; // Version 4, IHL 5 packet[9] = 6; // Protocol: TCP packet[12..16].copy_from_slice(&[192, 168, 1, 1]); // src IP packet[16..20].copy_from_slice(&[192, 168, 1, 2]); // dst IP // TCP header - set data offset to 4 (invalid, must be at least 5) packet[32] = 0x40; // Data offset = 4 let result = PacketParser::parse(&packet); assert!( result.is_err(), "shouldrefuse data_offset < 5 TCP countpacket" ); } #[test] fn test_valid_tcp_packet() { // Test a valid IPv4 packet with TCP let mut packet = vec![0x00; 40]; packet[0] = 0x45; // Version 4, IHL 5 packet[9] = 6; // Protocol: TCP packet[12..16].copy_from_slice(&[192, 168, 1, 1]); // src IP packet[16..20].copy_from_slice(&[192, 168, 1, 2]); // dst IP // TCP header packet[20..22].copy_from_slice(&[0x00, 0x50]); // src port 80 packet[22..24].copy_from_slice(&[0x00, 0x50]); // dst port 80 packet[32] = 0x50; // Data offset = 5 (20 bytes) packet[33] = 0x02; // SYN flag let result = PacketParser::parse(&packet); assert!(result.is_ok(), "valid TCP countpacketshouldParsesuccess"); let p = result.unwrap(); assert_eq!(p.src_port, 80); assert_eq!(p.dst_port, 80); assert!(p.tcp_header.is_some()); } #[test] fn test_packet_too_short() { // Packet shorter than minimum IPv4 header let packet = vec![0x45; 10]; let result = PacketParser::parse(&packet); assert!(result.is_err(), "too shortcountpacketshould berefuse"); } #[test] fn test_invalid_ip_version() { // IP version 3 (invalid, should be 4 or 6) let mut packet = vec![0x00; 20]; packet[0] = 0x35; // Version 3, IHL 5 let result = PacketParser::parse(&packet); assert!(result.is_err(), "invalid IP versionshould berefuse"); }
}
